import { DOCUMENT } from '@angular/common';
import { AnimationBuilder, style, animate } from '@angular/animations';
import { Component, ViewEncapsulation, Input, HostBinding, ElementRef, EventEmitter, Renderer, ChangeDetectorRef, Inject, Output, ContentChild, ContentChildren, HostListener, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';

const _c0 = ["*"];
const _c1 = [[["mgl-timeline-entry-side"]], [["mgl-timeline-entry-dot"]], [["mgl-timeline-entry-header"]], [["mgl-timeline-entry-content"]]];
const _c2 = ["mgl-timeline-entry-side", "mgl-timeline-entry-dot", "mgl-timeline-entry-header", "mgl-timeline-entry-content"];
class MglTimelineEntryHeaderComponent {
}
MglTimelineEntryHeaderComponent.ɵfac = function MglTimelineEntryHeaderComponent_Factory(t) { return new (t || MglTimelineEntryHeaderComponent)(); };
MglTimelineEntryHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineEntryHeaderComponent, selectors: [["mgl-timeline-entry-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MglTimelineEntryHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["mgl-timeline-entry-header{position:relative;display:block;overflow:hidden;padding:15px;text-align:center}"], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineEntryHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline-entry-header',
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry-header{position:relative;display:block;overflow:hidden;padding:15px;text-align:center}"]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineEntryDotComponent {
    /**
     * @param {?} animationBuilder
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} changeDetectorRef
     * @param {?} document
     */
    constructor(animationBuilder, elementRef, renderer, changeDetectorRef, document) {
        this.animationBuilder = animationBuilder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this._expanded = false;
        this._alternate = false;
        this._mobile = false;
        this._size = 50;
        this.animationDone = new EventEmitter();
        this.clazz = 'primary';
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set size(size) {
        this._size = size;
        this.setStyle();
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @param {?} alternate
     * @return {?}
     */
    set alternate(alternate) {
        this._alternate = alternate;
        this.setStyle();
    }
    /**
     * @return {?}
     */
    get alternate() {
        return this._alternate;
    }
    /**
     * @param {?} mobile
     * @return {?}
     */
    set mobile(mobile) {
        this._mobile = mobile;
        this.setStyle();
    }
    /**
     * @return {?}
     */
    get mobile() {
        return this._mobile;
    }
    /**
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        /** @type {?} */
        const animate$$1 = this._expanded !== expanded;
        this._expanded = expanded;
        animate$$1 ? this.animate() : this.setStyle();
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initialStyle = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        this.setStyle();
        this.changeDetectorRef.detectChanges();
    }
    /**
     * @private
     * @return {?}
     */
    getCollapsedStyle() {
        return {
            top: '50%',
            left: (this.alternate || this.mobile) ? '-5px' : 'calc(100% + 5px)',
            width: this.size + 'px',
            height: this.size + 'px',
            opacity: 1,
            transform: 'translateY(-50%) translateX(-50%)',
            boxShadow: this.initialStyle && this.initialStyle.boxShadow,
            borderRadius: '100px'
        };
    }
    /**
     * @private
     * @return {?}
     */
    getTransitionStyle() {
        return Object.assign({}, this.getCollapsedStyle(), { left: '50%', opacity: 0.5, boxShadow: 'none' });
    }
    /**
     * @private
     * @return {?}
     */
    getExpandedStyle() {
        return Object.assign({}, this.getTransitionStyle(), { left: '0', transform: 'translateX(0) translateY(-50%)', width: '100%', height: '100%', opacity: 1, borderRadius: 0 });
    }
    /**
     * @private
     * @return {?}
     */
    animate() {
        this.destroyAnimation();
        if (this.expanded) {
            this.animation = this.animationBuilder
                .build([
                style(this.getCollapsedStyle()),
                animate('200ms ease', style(this.getTransitionStyle())),
                animate('200ms ease', style(this.getExpandedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            this.animation.onDone(() => this.animationDone.emit({ toState: 'expanded' }));
            this.animation.play();
        }
        else {
            this.animationBuilder;
            this.animation = this.animationBuilder
                .build([
                style(this.getExpandedStyle()),
                animate('100ms ease', style(this.getTransitionStyle())),
                animate('100ms ease', style(this.getCollapsedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            this.animation.onDone(() => this.animationDone.emit({ toState: 'collapsed' }));
            this.animation.play();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setStyle() {
        this.destroyAnimation();
        /** @type {?} */
        const baseStyle = this.expanded ? this.getExpandedStyle() : this.getCollapsedStyle();
        Object.keys(baseStyle).forEach(property => {
            this.renderer.setElementStyle(this.elementRef.nativeElement, property, baseStyle[property]);
        });
    }
    /**
     * @private
     * @return {?}
     */
    destroyAnimation() {
        if (this.animation) {
            this.animation.destroy();
            delete this.animation;
        }
    }
}
MglTimelineEntryDotComponent.ɵfac = function MglTimelineEntryDotComponent_Factory(t) { return new (t || MglTimelineEntryDotComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
MglTimelineEntryDotComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineEntryDotComponent, selectors: [["mgl-timeline-entry-dot"]], hostVars: 2, hostBindings: function MglTimelineEntryDotComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.clazz);
    } }, inputs: { clazz: ["class", "clazz"], size: "size" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MglTimelineEntryDotComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["mgl-timeline-entry-dot{display:block;position:absolute}"], encapsulation: 2 });
/** @nocollapse */
MglTimelineEntryDotComponent.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
MglTimelineEntryDotComponent.propDecorators = {
    clazz: [{ type: Input, args: ['class',] }, { type: HostBinding, args: ['class',] }],
    size: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineEntryDotComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline-entry-dot',
                template: "<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry-dot{display:block;position:absolute}"]
            }]
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: ɵngcc0.ElementRef }, { type: Renderer }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { clazz: [{
            type: Input,
            args: ['class']
        }, {
            type: HostBinding,
            args: ['class']
        }], size: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineEntryContentComponent {
    /**
     * @param {?} elementRef
     * @param {?} animationBuilder
     * @param {?} renderer
     */
    constructor(elementRef, animationBuilder, renderer) {
        this.elementRef = elementRef;
        this.animationBuilder = animationBuilder;
        this.renderer = renderer;
        this.animationDone = new EventEmitter();
        this._expanded = false;
    }
    /**
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        this.contentHeight = this.elementRef.nativeElement.scrollHeight;
        /** @type {?} */
        const animate$$1 = this._expanded !== expanded;
        this._expanded = expanded;
        animate$$1 ? this.animate() : this.setStyle;
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.contentHeight = this.elementRef.nativeElement.scrollHeight;
        this.setStyle();
    }
    /**
     * @private
     * @return {?}
     */
    getCollapsedStyle() {
        return {
            height: '0px'
        };
    }
    /**
     * @private
     * @return {?}
     */
    getExpandedStyle() {
        return {
            height: this.contentHeight + 'px'
        };
    }
    /**
     * @return {?}
     */
    animate() {
        if (this.expanded) {
            /** @type {?} */
            const animation = this.animationBuilder
                .build([
                style(this.getCollapsedStyle()),
                animate('100ms ease', style(this.getExpandedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            animation.onDone(() => this.animationDone.emit({ toState: 'expanded' }));
            animation.play();
        }
        else {
            this.animationBuilder;
            /** @type {?} */
            const animation = this.animationBuilder
                .build([
                style(this.getExpandedStyle()),
                animate('200ms ease', style(this.getCollapsedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            animation.onDone(() => this.animationDone.emit({ toState: 'collapsed' }));
            animation.play();
        }
    }
    /**
     * @return {?}
     */
    setStyle() {
        /** @type {?} */
        const baseStyle = this.expanded ? this.getExpandedStyle() : this.getCollapsedStyle();
        Object.keys(baseStyle).forEach(property => {
            this.renderer.setElementStyle(this.elementRef.nativeElement, property, baseStyle[property]);
        });
    }
}
MglTimelineEntryContentComponent.ɵfac = function MglTimelineEntryContentComponent_Factory(t) { return new (t || MglTimelineEntryContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(Renderer)); };
MglTimelineEntryContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineEntryContentComponent, selectors: [["mgl-timeline-entry-content"]], ngContentSelectors: _c0, decls: 2, vars: 0, template: function MglTimelineEntryContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: ["mgl-timeline-entry-content{position:relative;display:block;overflow:hidden}mgl-timeline-entry-content>div{padding:10px}"], encapsulation: 2 });
/** @nocollapse */
MglTimelineEntryContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: Renderer }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineEntryContentComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline-entry-content',
                template: "<div><ng-content></ng-content></div>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry-content{position:relative;display:block;overflow:hidden}mgl-timeline-entry-content>div{padding:10px}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.AnimationBuilder }, { type: Renderer }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineEntrySideComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set alternate(value) {
        this.elementRef.nativeElement.classList.toggle('alternate', value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobile(value) {
        this.elementRef.nativeElement.classList.toggle('mobile', value);
    }
}
MglTimelineEntrySideComponent.ɵfac = function MglTimelineEntrySideComponent_Factory(t) { return new (t || MglTimelineEntrySideComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MglTimelineEntrySideComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineEntrySideComponent, selectors: [["mgl-timeline-entry-side"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MglTimelineEntrySideComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["mgl-timeline-entry-side{position:absolute;top:0;left:100%;width:100%;text-align:center}mgl-timeline-entry-side.alternate{left:-100%}mgl-timeline-entry-side.mobile{display:none}"], encapsulation: 2 });
/** @nocollapse */
MglTimelineEntrySideComponent.ctorParameters = () => [
    { type: ElementRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineEntrySideComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline-entry-side',
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry-side{position:absolute;top:0;left:100%;width:100%;text-align:center}mgl-timeline-entry-side.alternate{left:-100%}mgl-timeline-entry-side.mobile{display:none}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineEntryComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.subscriptions = [];
        this.focusOnOpen = false;
        this._mobile = false;
        this.changed = new EventEmitter();
        this.animationDone = new EventEmitter();
    }
    /**
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        if (this.dot && expanded) {
            this.dot.expanded = expanded;
        }
        else {
            this.content.expanded = expanded;
        }
        this.changed.emit(expanded);
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this.dot ? (this.dot.expanded && this.content.expanded) : this.content.expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobile(value) {
        this.elementRef.nativeElement.classList.toggle('mobile', value);
        if (this.dot) {
            this.dot.mobile = value;
        }
        if (this.side) {
            this.side.mobile = value;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.dot) {
            this.subscriptions.push(this.dot.animationDone.subscribe(event => {
                if (event.toState === 'expanded') {
                    this.content.expanded = true;
                }
                else {
                    this.animationDone.emit(event);
                }
            }));
        }
        if (this.content) {
            this.subscriptions.push(this.content.animationDone.subscribe(event => {
                if (this.dot && event.toState === 'collapsed') {
                    this.dot.expanded = false;
                }
                else {
                    if (this.focusOnOpen) {
                        this.elementRef.nativeElement.scrollIntoView({ behavior: 'smooth' });
                    }
                    this.animationDone.emit(event);
                }
            }));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set alternate(value) {
        this.elementRef.nativeElement.classList.toggle('alternate', value);
        if (this.dot) {
            this.dot.alternate = value;
        }
        if (this.side) {
            this.side.alternate = value;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
    /**
     * @return {?}
     */
    collapse() {
        this.expanded = false;
    }
    /**
     * @return {?}
     */
    expand() {
        this.expanded = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        /** @type {?} */
        const headerFound = this.containsInPath(event, 'mgl-timeline-entry-header');
        /** @type {?} */
        const dotFound = this.containsInPath(event, 'mgl-timeline-entry-dot');
        if (headerFound || dotFound) {
            this.expanded = !this.expanded;
        }
    }
    /**
     * @private
     * @param {?} mouseEvent
     * @param {?} name
     * @return {?}
     */
    containsInPath(mouseEvent, name) {
        /** @type {?} */
        let currentElem = (/** @type {?} */ (mouseEvent.target));
        while (currentElem) {
            if (currentElem.localName === name) {
                return true;
            }
            currentElem = currentElem.parentElement;
        }
        return false;
    }
}
MglTimelineEntryComponent.ɵfac = function MglTimelineEntryComponent_Factory(t) { return new (t || MglTimelineEntryComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MglTimelineEntryComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineEntryComponent, selectors: [["mgl-timeline-entry"]], contentQueries: function MglTimelineEntryComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MglTimelineEntryContentComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MglTimelineEntryHeaderComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MglTimelineEntryDotComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MglTimelineEntrySideComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dot = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.side = _t.first);
    } }, hostVars: 2, hostBindings: function MglTimelineEntryComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("expanded", ctx.expanded);
    } }, outputs: { changed: "expand", animationDone: "animationDone" }, ngContentSelectors: _c2, decls: 6, vars: 0, consts: [[1, "mgl-timeline-entry-card"], [1, "mgl-timeline-entry-card-header", 3, "click"]], template: function MglTimelineEntryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵlistener("click", function MglTimelineEntryComponent_Template_div_click_2_listener($event) { return ctx.toggle($event); });
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(5, 3);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: ["mgl-timeline-entry{display:block;position:relative;margin-bottom:50px;width:calc(50% - 5px)}mgl-timeline-entry.alternate{margin-left:calc(50% + 5px)}mgl-timeline-entry.mobile{width:calc(100% - 30px);margin-left:30px}mgl-timeline-entry .mgl-timeline-entry-card{background-color:#f0f0f0}mgl-timeline-entry .mgl-timeline-entry-card .mgl-timeline-entry-card-header{position:relative;background-color:#e6e6e6}"], encapsulation: 2 });
/** @nocollapse */
MglTimelineEntryComponent.ctorParameters = () => [
    { type: ElementRef }
];
MglTimelineEntryComponent.propDecorators = {
    expanded: [{ type: HostBinding, args: ['class.expanded',] }],
    changed: [{ type: Output, args: ['expand',] }],
    animationDone: [{ type: Output }],
    content: [{ type: ContentChild, args: [MglTimelineEntryContentComponent,] }],
    header: [{ type: ContentChild, args: [MglTimelineEntryHeaderComponent,] }],
    dot: [{ type: ContentChild, args: [MglTimelineEntryDotComponent,] }],
    side: [{ type: ContentChild, args: [MglTimelineEntrySideComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineEntryComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline-entry',
                template: "<ng-content select=\"mgl-timeline-entry-side\"></ng-content>\n<div class=\"mgl-timeline-entry-card\">\n  <div class=\"mgl-timeline-entry-card-header\" (click)=\"toggle($event)\">\n    <ng-content select=\"mgl-timeline-entry-dot\"></ng-content>\n    <ng-content select=\"mgl-timeline-entry-header\"></ng-content>\n  </div>\n  <ng-content select=\"mgl-timeline-entry-content\"></ng-content>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry{display:block;position:relative;margin-bottom:50px;width:calc(50% - 5px)}mgl-timeline-entry.alternate{margin-left:calc(50% + 5px)}mgl-timeline-entry.mobile{width:calc(100% - 30px);margin-left:30px}mgl-timeline-entry .mgl-timeline-entry-card{background-color:#f0f0f0}mgl-timeline-entry .mgl-timeline-entry-card .mgl-timeline-entry-card-header{position:relative;background-color:#e6e6e6}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { changed: [{
            type: Output,
            args: ['expand']
        }], animationDone: [{
            type: Output
        }], expanded: [{
            type: HostBinding,
            args: ['class.expanded']
        }], content: [{
            type: ContentChild,
            args: [MglTimelineEntryContentComponent]
        }], header: [{
            type: ContentChild,
            args: [MglTimelineEntryHeaderComponent]
        }], dot: [{
            type: ContentChild,
            args: [MglTimelineEntryDotComponent]
        }], side: [{
            type: ContentChild,
            args: [MglTimelineEntrySideComponent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineComponent {
    /**
     * @param {?} elementRef
     * @param {?} changeDetectorRef
     */
    constructor(elementRef, changeDetectorRef) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.toggle = true;
        this.mobileWidthThreshold = 640;
        this.alternate = true;
        this.side = 'left';
        this._focusOnOpen = false;
        this.subscriptions = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobile(value) {
        this.content && this.content.forEach(entry => entry.mobile = value);
        this.elementRef.nativeElement.classList.toggle('mobile', value);
    }
    /**
     * @return {?}
     */
    get mobile() {
        return this.elementRef.nativeElement.classList.contains('mobile');
    }
    /**
     * @param {?} focusOnOpen
     * @return {?}
     */
    set focusOnOpen(focusOnOpen) {
        this.content && this.content.forEach(entry => entry.focusOnOpen = focusOnOpen);
        this._focusOnOpen = focusOnOpen;
    }
    /**
     * @return {?}
     */
    get focusOnOpen() {
        return this._focusOnOpen;
    }
    /**
     * @param {?} simpleChanges
     * @return {?}
     */
    ngOnChanges(simpleChanges) {
        this.updateContent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.mobile = this.elementRef.nativeElement.clientWidth < this.mobileWidthThreshold;
        setTimeout(() => this.updateContent());
        this.content.changes.subscribe(changes => {
            this.updateContent();
        });
    }
    /**
     * @private
     * @return {?}
     */
    updateContent() {
        this.ngOnDestroy();
        if (this.content) {
            this.content.forEach((entry, index) => {
                if (this.toggle) {
                    this.subscriptions.push(entry.changed.subscribe(state => {
                        if (state === true) {
                            this.content.filter(e => e !== entry).forEach(e => e.collapse());
                        }
                    }));
                }
                entry.alternate = this.alternate ? (index % 2 !== 0) : (this.side === 'right');
                entry.mobile = this.mobile;
                entry.focusOnOpen = this.focusOnOpen;
            });
        }
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onResize(ev) {
        console.log(this.mobileWidthThreshold);
        this.mobile = this.elementRef.nativeElement.clientWidth < this.mobileWidthThreshold;
    }
}
MglTimelineComponent.ɵfac = function MglTimelineComponent_Factory(t) { return new (t || MglTimelineComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
MglTimelineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MglTimelineComponent, selectors: [["mgl-timeline"]], contentQueries: function MglTimelineComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MglTimelineEntryComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t);
    } }, hostBindings: function MglTimelineComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function MglTimelineComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { toggle: "toggle", mobileWidthThreshold: "mobileWidthThreshold", alternate: "alternate", side: "side", focusOnOpen: "focusOnOpen" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, "mgl-timeline-line"]], template: function MglTimelineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
    } }, styles: ["mgl-timeline{position:relative;display:block;padding:50px 0}mgl-timeline .mgl-timeline-line{position:absolute;top:0;height:100%;background-color:#a0a0a0;left:50%;width:10px;-webkit-transform:translateX(-50%);transform:translateX(-50%)}mgl-timeline.mobile .mgl-timeline-line{left:20px;-webkit-transform:none;transform:none}"], encapsulation: 2 });
/** @nocollapse */
MglTimelineComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
MglTimelineComponent.propDecorators = {
    toggle: [{ type: Input }],
    mobileWidthThreshold: [{ type: Input }],
    alternate: [{ type: Input }],
    side: [{ type: Input }],
    focusOnOpen: [{ type: Input }],
    content: [{ type: ContentChildren, args: [MglTimelineEntryComponent,] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineComponent, [{
        type: Component,
        args: [{
                selector: 'mgl-timeline',
                template: "<div class=\"mgl-timeline-line\"></div>\n<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline{position:relative;display:block;padding:50px 0}mgl-timeline .mgl-timeline-line{position:absolute;top:0;height:100%;background-color:#a0a0a0;left:50%;width:10px;-webkit-transform:translateX(-50%);transform:translateX(-50%)}mgl-timeline.mobile .mgl-timeline-line{left:20px;-webkit-transform:none;transform:none}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { toggle: [{
            type: Input
        }], mobileWidthThreshold: [{
            type: Input
        }], alternate: [{
            type: Input
        }], side: [{
            type: Input
        }], focusOnOpen: [{
            type: Input
        }], onResize: [{
            type: HostListener,
            args: ['window:resize', ['$event']]
        }], content: [{
            type: ContentChildren,
            args: [MglTimelineEntryComponent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MglTimelineModule {
}
MglTimelineModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MglTimelineModule });
MglTimelineModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MglTimelineModule_Factory(t) { return new (t || MglTimelineModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MglTimelineModule, { declarations: [MglTimelineComponent,
        MglTimelineEntryComponent,
        MglTimelineEntryHeaderComponent,
        MglTimelineEntrySideComponent,
        MglTimelineEntryContentComponent,
        MglTimelineEntryDotComponent], exports: [MglTimelineComponent,
        MglTimelineEntryComponent,
        MglTimelineEntryHeaderComponent,
        MglTimelineEntrySideComponent,
        MglTimelineEntryContentComponent,
        MglTimelineEntryDotComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MglTimelineModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    MglTimelineComponent,
                    MglTimelineEntryComponent,
                    MglTimelineEntryHeaderComponent,
                    MglTimelineEntrySideComponent,
                    MglTimelineEntryContentComponent,
                    MglTimelineEntryDotComponent
                ],
                exports: [
                    MglTimelineComponent,
                    MglTimelineEntryComponent,
                    MglTimelineEntryHeaderComponent,
                    MglTimelineEntrySideComponent,
                    MglTimelineEntryContentComponent,
                    MglTimelineEntryDotComponent
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MglTimelineModule, MglTimelineEntryContentComponent as ɵc, MglTimelineEntryDotComponent as ɵe, MglTimelineEntryHeaderComponent as ɵd, MglTimelineEntrySideComponent as ɵf, MglTimelineEntryComponent as ɵb, MglTimelineComponent as ɵa };

//# sourceMappingURL=angular-mgl-timeline.js.map