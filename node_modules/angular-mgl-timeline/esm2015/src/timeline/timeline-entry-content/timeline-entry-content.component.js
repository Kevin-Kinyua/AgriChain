/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { AnimationBuilder, style, animate } from '@angular/animations';
import { Component, EventEmitter, ElementRef, Renderer, ViewEncapsulation } from '@angular/core';
export class MglTimelineEntryContentComponent {
    /**
     * @param {?} elementRef
     * @param {?} animationBuilder
     * @param {?} renderer
     */
    constructor(elementRef, animationBuilder, renderer) {
        this.elementRef = elementRef;
        this.animationBuilder = animationBuilder;
        this.renderer = renderer;
        this.animationDone = new EventEmitter();
        this._expanded = false;
    }
    /**
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        this.contentHeight = this.elementRef.nativeElement.scrollHeight;
        /** @type {?} */
        const animate = this._expanded !== expanded;
        this._expanded = expanded;
        animate ? this.animate() : this.setStyle;
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.contentHeight = this.elementRef.nativeElement.scrollHeight;
        this.setStyle();
    }
    /**
     * @private
     * @return {?}
     */
    getCollapsedStyle() {
        return {
            height: '0px'
        };
    }
    /**
     * @private
     * @return {?}
     */
    getExpandedStyle() {
        return {
            height: this.contentHeight + 'px'
        };
    }
    /**
     * @return {?}
     */
    animate() {
        if (this.expanded) {
            /** @type {?} */
            const animation = this.animationBuilder
                .build([
                style(this.getCollapsedStyle()),
                animate('100ms ease', style(this.getExpandedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            animation.onDone(() => this.animationDone.emit({ toState: 'expanded' }));
            animation.play();
        }
        else {
            this.animationBuilder;
            /** @type {?} */
            const animation = this.animationBuilder
                .build([
                style(this.getExpandedStyle()),
                animate('200ms ease', style(this.getCollapsedStyle())),
            ])
                .create(this.elementRef.nativeElement);
            animation.onDone(() => this.animationDone.emit({ toState: 'collapsed' }));
            animation.play();
        }
    }
    /**
     * @return {?}
     */
    setStyle() {
        /** @type {?} */
        const baseStyle = this.expanded ? this.getExpandedStyle() : this.getCollapsedStyle();
        Object.keys(baseStyle).forEach(property => {
            this.renderer.setElementStyle(this.elementRef.nativeElement, property, baseStyle[property]);
        });
    }
}
MglTimelineEntryContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-timeline-entry-content',
                template: "<div><ng-content></ng-content></div>",
                encapsulation: ViewEncapsulation.None,
                styles: ["mgl-timeline-entry-content{position:relative;display:block;overflow:hidden}mgl-timeline-entry-content>div{padding:10px}"]
            }] }
];
/** @nocollapse */
MglTimelineEntryContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: Renderer }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    MglTimelineEntryContentComponent.prototype.contentHeight;
    /** @type {?} */
    MglTimelineEntryContentComponent.prototype.animationDone;
    /**
     * @type {?}
     * @private
     */
    MglTimelineEntryContentComponent.prototype._expanded;
    /**
     * @type {?}
     * @private
     */
    MglTimelineEntryContentComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    MglTimelineEntryContentComponent.prototype.animationBuilder;
    /**
     * @type {?}
     * @private
     */
    MglTimelineEntryContentComponent.prototype.renderer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZWxpbmUtZW50cnktY29udGVudC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLW1nbC10aW1lbGluZS8iLCJzb3VyY2VzIjpbInNyYy90aW1lbGluZS90aW1lbGluZS1lbnRyeS1jb250ZW50L3RpbWVsaW5lLWVudHJ5LWNvbnRlbnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBaUIsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBUWhILE1BQU0sT0FBTyxnQ0FBZ0M7Ozs7OztJQWtCM0MsWUFBb0IsVUFBc0IsRUFBVSxnQkFBa0MsRUFBVSxRQUFrQjtRQUE5RixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVU7UUFmbEgsa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBRWhDLGNBQVMsR0FBWSxLQUFLLENBQUM7SUFhbUYsQ0FBQzs7Ozs7SUFYdkgsSUFBSSxRQUFRLENBQUMsUUFBaUI7UUFDNUIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7O2NBQzFELE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxLQUFLLFFBQVE7UUFDM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFDMUIsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUE7SUFDMUMsQ0FBQzs7OztJQUVELElBQUksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDOzs7O0lBSUQsZUFBZTtRQUNiLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDO1FBQ2hFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixDQUFDOzs7OztJQUVPLGlCQUFpQjtRQUN2QixPQUFPO1lBQ0wsTUFBTSxFQUFFLEtBQUs7U0FDZCxDQUFBO0lBQ0gsQ0FBQzs7Ozs7SUFFTyxnQkFBZ0I7UUFDdEIsT0FBTztZQUNMLE1BQU0sRUFBRSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUk7U0FDbEMsQ0FBQTtJQUNILENBQUM7Ozs7SUFFRCxPQUFPO1FBQ0wsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFOztrQkFDWCxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQjtpQkFDcEMsS0FBSyxDQUFDO2dCQUNMLEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDL0IsT0FBTyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQzthQUN0RCxDQUFDO2lCQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztZQUN4QyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6RSxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7U0FFbEI7YUFBTTtZQUNMLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQTs7a0JBQ2YsU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0I7aUJBQ3BDLEtBQUssQ0FBQztnQkFDTCxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUM7YUFDdkQsQ0FBQztpQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDeEMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUUsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2xCO0lBQ0gsQ0FBQzs7OztJQUVELFFBQVE7O2NBQ0EsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7UUFDcEYsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFBO1FBQzdGLENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQzs7O1lBeEVGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNEJBQTRCO2dCQUN0QyxnREFBc0Q7Z0JBRXRELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOzthQUN0Qzs7OztZQVBpQyxVQUFVO1lBRG5DLGdCQUFnQjtZQUNvQyxRQUFROzs7Ozs7O0lBVW5FLHlEQUFzQjs7SUFDdEIseURBQXdDOzs7OztJQUV4QyxxREFBbUM7Ozs7O0lBYXZCLHNEQUE4Qjs7Ozs7SUFBRSw0REFBMEM7Ozs7O0lBQUUsb0RBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uQnVpbGRlciwgc3R5bGUsIGFuaW1hdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBBZnRlclZpZXdJbml0LCBSZW5kZXJlciwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWdsLXRpbWVsaW5lLWVudHJ5LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZVVybDogJy4vdGltZWxpbmUtZW50cnktY29udGVudC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3RpbWVsaW5lLWVudHJ5LWNvbnRlbnQuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBNZ2xUaW1lbGluZUVudHJ5Q29udGVudENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gIHByaXZhdGUgY29udGVudEhlaWdodDtcbiAgYW5pbWF0aW9uRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc2V0IGV4cGFuZGVkKGV4cGFuZGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IGFuaW1hdGUgPSB0aGlzLl9leHBhbmRlZCAhPT0gZXhwYW5kZWQ7XG4gICAgdGhpcy5fZXhwYW5kZWQgPSBleHBhbmRlZDtcbiAgICBhbmltYXRlID8gdGhpcy5hbmltYXRlKCkgOiB0aGlzLnNldFN0eWxlXG4gIH1cblxuICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIGFuaW1hdGlvbkJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIHRoaXMuc2V0U3R5bGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q29sbGFwc2VkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogJzBweCdcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEV4cGFuZGVkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogdGhpcy5jb250ZW50SGVpZ2h0ICsgJ3B4J1xuICAgIH1cbiAgfVxuXG4gIGFuaW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uQnVpbGRlclxuICAgICAgICAuYnVpbGQoW1xuICAgICAgICAgIHN0eWxlKHRoaXMuZ2V0Q29sbGFwc2VkU3R5bGUoKSksXG4gICAgICAgICAgYW5pbWF0ZSgnMTAwbXMgZWFzZScsIHN0eWxlKHRoaXMuZ2V0RXhwYW5kZWRTdHlsZSgpKSksXG4gICAgICAgIF0pXG4gICAgICAgIC5jcmVhdGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICBhbmltYXRpb24ub25Eb25lKCgpID0+IHRoaXMuYW5pbWF0aW9uRG9uZS5lbWl0KHsgdG9TdGF0ZTogJ2V4cGFuZGVkJyB9KSk7XG4gICAgICBhbmltYXRpb24ucGxheSgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uQnVpbGRlclxuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25CdWlsZGVyXG4gICAgICAgIC5idWlsZChbXG4gICAgICAgICAgc3R5bGUodGhpcy5nZXRFeHBhbmRlZFN0eWxlKCkpLFxuICAgICAgICAgIGFuaW1hdGUoJzIwMG1zIGVhc2UnLCBzdHlsZSh0aGlzLmdldENvbGxhcHNlZFN0eWxlKCkpKSxcbiAgICAgICAgXSlcbiAgICAgICAgLmNyZWF0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgIGFuaW1hdGlvbi5vbkRvbmUoKCkgPT4gdGhpcy5hbmltYXRpb25Eb25lLmVtaXQoeyB0b1N0YXRlOiAnY29sbGFwc2VkJyB9KSk7XG4gICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldFN0eWxlKCkge1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IHRoaXMuZXhwYW5kZWQgPyB0aGlzLmdldEV4cGFuZGVkU3R5bGUoKSA6IHRoaXMuZ2V0Q29sbGFwc2VkU3R5bGUoKTtcbiAgICBPYmplY3Qua2V5cyhiYXNlU3R5bGUpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHByb3BlcnR5LCBiYXNlU3R5bGVbcHJvcGVydHldKVxuICAgIH0pXG4gIH1cblxufVxuIl19